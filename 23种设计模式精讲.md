# 23种设计模式

# 一、设计模式概述

## 1.代码质量好坏如何评价？

要想学习设计模式呢 我们就必须搞清楚设计模式到底在编程过程中起到了怎样的作用,在编程世界中它处在一个什么样的位置,它到底是一种抽象的设计思想,还是一套具体的落地方案.

在学习设计模式之前呢 我们需要了解一下 代码质量的评价标准和编程的方法论

我们经常会听到有人对项目代码进行评价,一般就会说：“代码写得很烂”或者“代码写得很好”。用“好”“烂”这样的词汇来描述代码质量，非常地笼统。

代码质量的评价标准非常之多，最常用的几个标准如下：

![image-20230806112327151](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806112327151.png)

**评价代码的质量,有以下几个常用标准:** 

**1 ) 可维护性**

可维护性强的代码指的是:  在不去破坏原有的代码设计以及不引入新的BUG的前提下,能够快速的修改或者新增代码.

不易维护的代码指的是: 在添加或者修改一些功能逻辑的时候,存在极大的引入新的BUG的风险,并且需要花费的时间也很长.

> 代码可维护性的评判标准比较模糊, 因为是否易维护是针对维护的人员来说的,不同水平的人对于同一份代码的维护能力是不同的. 所谓 ''难者不会 会者不难''. 对于同样的系统,熟悉它的资深工程师会觉得代码可维护性还可以,而新人则会因为能力不足、了解不够深入等原因觉得代码的可维护性不是很好.

**2 ) 可读性**

软件开发教父，Martin Fowler曾经说过一句话: "任何傻瓜都能够编写计算机能理解的代码，而优秀的程序员能够编写人类能理解的代码。" 这句话的意思非常容易理解,就是要求我们写出的代码是易读的、易理解的,因为代码的可读性会在很大程度上影响代码的可维护行性.

> code review ( 代码审查,一种测试代码可读性的手段 )
>
> 1.检查代码风格和编程规范: 代码是否符合编码规范、命名是否达意、注释是否详尽、模块划分是否清晰等
>
> 2.检查常规的 bad smell 和代码 bug: 是否存在重复代码、过长函数、过大类、过于亲密的两个 classes 等

**3 ) 可扩展性**

代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。

> 可扩展性的背后其实就是: "对修改关闭,对扩展开放" 这条设计原则,后面我们会详细的讲解

**4 ) 灵活性**

"灵活" 是指在添加新代码的时候，已有代码能够不受影响，不产生冲突，不出现排斥，在保证自身不遭到破坏的前提下灵活地接纳新代码。

> 下面的几个场景,可以体现代码的灵活性
>
> 1.添加新的功能代码时,原有代码已经预留了扩展点,我们不需要修改 直接在扩展点上新增代码即可.
>
> 2.当我们想实现一个功能模块时,发现原有代码中,已经抽象出了很多底层可以复用的模块、类等代码,我们可以直接拿来使用
>
> 3.当我们使用某组接口时,这组接口可以应对各种使用场景,满足不同需求,这个接口设计的十分的灵活易用.

**5 ) 简洁性**

我们要遵从KISS ( Keep It Simple Stupid) 原则，代码要尽可能的简单；但是思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。

> 代码的写法应当使别人理解它所需的时间最小化.  

**6 ) 可复用性** 

代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码.

> 可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所 要达到的最终效果
>
> 可复用性与DRY(Don't Repeat Yourself) 避免编写重复的代码逻辑. 原则关系紧密,后面我们会介绍有哪些编程方法可以提高代码复用性.

**7 ) 可测试性**

单元测试在一个完整的软件开发流程中是必不可少的、非常重要的一个环节。通常写单元测试并不难，但有的时候，有的代码和功能难以测试，导致写起测试来困难重重。所以写出的代码具有可测试性，具有很重要的作用。

> 代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏

## 2.编程方法论

想要拥有编写高质量代码的能力,我们就要学习一些编程的方法论.其中就包含面向对象（我们可以把它看成一种设计思想）、设计原则、设计模式、编程规范、重构技巧等等

![image-20230806112709090](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806112709090.png)

**代码重构的工具就是面向对象设计思想、设计原则、设计模式、编码规范。** 

**1 ) 面向对象**

面向对象是一种编程思想,也是一种编程范式. 现在比较流行的编程语言大部分都是面向对象编程语言.而大部分项目也都是基于面向对象编程风格进行开发的.

**2 ) 设计原则 (重点讲解)**

设计原则是指导我们代码设计的一些经验总结。在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据设计原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。

**常用的设计原则：**

- 单一职责原则
- 开闭原则
- 里氏代换原则
- 依赖倒转原则
- 接口隔离原则
- 迪米特法则

> 设计原则的特点就是比较的抽象,不需要死记硬背.根据自己所积累的经验和所处的业务场景, 去灵活的运用这些原则即可

**3 ) 设计模式 (重点讲解)** 

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。

> 设计模式是遵循设计原则的, 设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们 都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

**4 ) 编程规范**

编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具 体、更加偏重代码细节。

> 对于编码规范，考虑到很多书籍已经讲得很好了（比如《编写可读性代码的艺术》《代码大全》《代码整洁之道》等）。而且，每条编码规范都非常简单、非常明确，比较偏向于记忆，你只要照着来做 可以。

**5 ) 重构**

维基百科:  在软件工程学里，**重构**代码一词通常是指在不改变代码的外部行为情况下而修改源代码，有时非正式地称为“清理干净”。在极限编程或其他敏捷方法学中，重构常常是软件开发循环的一部分：开发者轮流增加新的测试和功能，并重构代码来增进内部的清晰性和一致性。

> 在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的 不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段， 能有效避免代码腐化到无可救药的地步。

**6 ) 总结**

提高代码质量的方法论包含: 

- 面向对象思想 (基础)
- 设计原则 (指导方针) 
- 设计模式 (设计原则的具体实现) 
- 编程规范  (提高代码可读性) 
- 重构 (面向对象设计思想、设计原则、设计模式、编码规范的融合贯通)

> 设计原则是高手的内功，设计模式是少林，武当，峨眉派的武术套路，规范是招式 出拳还 是横扫，重构是组合拳 融汇贯通各种组合，而想练好这些武功还要有扎实的基本功 面向对象,在这里呢 也提醒同学们一句,不要一味的去追求最新的技术(并不是说这样做不好,但是千万不要本末倒置),而忘记了一个程序员最重要的能力 是写出高质量的代码.

## 3.设计模式概述

**设计模式（Design pattern）**是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结

> 在GOF编写的设计模式(可复用面向对象软件的基础)一书中说道:  本书涉及的设计模式**并不描述新的或未经证实的设计**，我们只**收录那些在不同系统中多次使用过的成功设计**。

大部分设计模式要解决的都是代码的可重用性、可扩展性问题

> 如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码，所以，它们跟平时的编码会有直接的关系，也会直接影响到你的开发能力。

- 学习设计模式的好处

  - 能够从容应对面试中的设计模式相关问题
  - 不再编写 bullshit-code

  > 代码能力是一个程序员最基础的能力，是基本功，是展示一个程序员基础素养的最直接的衡量标准。你写的代码，实 际上就是你名片。通过学习设计模式,告别烂代码的编写,避免比如类设计不合理,代码结构混乱,分层不清晰 等等这样的代码问题. 让我们编写的代码成为团队中的标杆.

  - 提高复杂代码的设计和开发能力

  > 不再只是根据业务需求翻译代码,填充代码. 而是能够通过所学习的设计模式的相关知识写出高质量的代码.即使面对复杂代码功能或者系统的设计开发也能得心应手.

  - 有助于我们读懂源码,学习框架更加事半功倍

  > 对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度。所以我们需要更多的去学习研究各种框架,中间件的底层原理,而这些优秀的框架 中间件的源码中会使用到很多设计思想 设计原则 设计模式 ,所以为了更好的独懂这些开源项目,我们必须好设计模式相关知识.

## 4.产生背景

**"设计模式"** 最初并不是出现在软件设计中，而是被用于建筑领域的设计中。

1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任`克里斯托夫·亚历山大（Christopher Alexander）`在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。

![image-20230806120639442](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806120639442.png)

**四人帮（GOF）**

1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。

> 在之前设计模式的**绝大部分以往并无文本记录**，它们或是来源于面向对象设计者圈子里的非正式交流，或是来源于某些成功的面向对象系统的某些部分，但对**设计新手**来说，这些东西是很难学得到的。尽管这些设计**不包括新的思路**，但我们**用一种新的、便于理解的方式将其展现给读者**，即：具有统一格式的、已分类编目的若干组设计模式。

1994 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。

> 备注：由于书名太长， 人们将其简称为 "四人组 （Gang of Four， GoF） 的书"， 并且很快进一步简化为 "GoF 的书"。

![image-20230806120750579](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806120750579.png)

## 5.设计模式分类

> 按照不同的业务领域和场景的复杂程度，以及选择不同的设计模式，在整个系统建设落地中都会有不同的呈现形式。
>
> 就像出行可以选择不同的交通工具一样，如近距离骑自行车、中短程驾车、远程乘坐高铁或飞机等

GoF设计模式只有23个，但是它们各具特色 ，每个模式都为某一个可重复的设计问题提供了一套解决方案。

根据它们的用途，设计模式可分为 **创建型(Creational) **，**结构型(Structural)  **和**行为型(Behavioral)**

- **创建型模式(5种)：提供创建对象的机制，提升已有代码的灵活性和可复用性**

  常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式

  不常用的有：原型模式

  ![](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/01.jpg)

- **结构型模式(7种)：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效**

  常用的有：代理模式、桥接模式、装饰者模式、适配器模式

  不常用的有：门面模式、组合模式、享元模式

  ![image-20230806121219578](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806121219578.png)

- **行为模式(11种)：负责对象间的高效沟通和职责传递委派**

  - 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式
  - 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式

  ![image-20230806121303294](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806121303294.png)

# 二、UML图

统一建模语言（Unified  Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。

UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。  

这里只介绍类图.

> 我们要去研究一个设计模式的时候,是需要借助UML类图更加准确的描述所使用的设计模式,和设计模式下类与类之间的关系

## 1.类图概述

类图(Class diagram) 是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。

## 2.类图的作用

在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；

类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。

## 3.类图表示法

UML类图中具体类、抽象类、接口和包有不同的表示方法

### 3.1 在UML类图中表示具体类

具体类在类图中用矩形框表示，矩形框分为三层：第一层是类名字；第二层是类的成员变量；第三层是类的方法。成员变量以及方法前的访问修饰符用符号来表示：

- “+” 表示 `public`
- “-” 表示 `private`
- “#” 表示 `protected`
- 不带符号表示 `default`

![image-20230806152315252](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806152315252.png)

### 3.2 在UML类图中表示抽象类

抽象类在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用**斜体字**表示，如图所示

![image-20230806152358265](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806152358265.png)

### 3.3 在UML类图中表示接口

接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 <<interface>>表示，下面是接口的名字，第二层是方法。

![image-20230806152437419](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806152437419.png)

> 此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线）。圆圈旁为接口名称，接口方法在实现类中出现

### 3.4 在类图中表示关系

类和类、类和接口、接口和接口之间存在一定关系，UML类图中一般会有连线指明它们之间的关系。

关系共有六种类型 ,如下图：

![image-20230806152837509](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806152837509.png)

#### 3.4.1 实现关系

实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作

在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口

例如，汽车和船实现了交通工具，其类图:

![image-20230806153457540](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806153457540.png)

#### 3.4.2 泛化关系

泛化关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。

在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。

例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：

![image-20230806154026714](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806154026714.png)

#### 3.4.3 关联关系

关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。

我们先介绍一般关联关系, 一般关联关系又可以分为单向关联，双向关联，自关联。

**1) 单向关联**

![image-20230806154334327](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806154334327.png)

在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现

**2) 双向关联**

![image-20230806154557110](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806154557110.png)

从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。

在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买

**3) 自关联**

![image-20230806154757129](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806154757129.png)

自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。

##### 3.4.3.1 聚合关系

聚合关系是关联关系的一种，表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分

> 在代码中: 比如A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象

```java
public class A{

	private B b;
	
	public A(B b){
		this.b = b;
	}
}
```

在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。

下图所示是大学和教师的关系图：

![image-20230806155755474](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806155755474.png)

##### 3.4.3.2 组合关系

组合关系是一种强‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的声明周期一样

> 在代码中: 比如A 类对象包含 B 类对象，B 类对象的生命周期依赖A 类对象的生命周期，B 类对象不可以单独存在

```java
public class A{
    
    private B b;
    
    public A(){
        this.b = new B();
    }
    
}
```

在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。

下图所示是头和嘴的关系图：

![image-20230806162701211](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806162701211.png)

##### 3.4.3.3 依赖关系

依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。

在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。

在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。

下图所示是司机和汽车的关系图，司机驾驶汽车：

![image-20230806162332236](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806162332236.png)

## 4.UML类图总结

之前我们一共学习了六种类关系的表示方式

- 实现关系
- 泛化关系
- 关联关系
- 聚合关系
- 组合关系
- 依赖关系

为了节省学习成本, 方便记忆,我们可以将类和类之间的关系重新调整一下,使其更加贴近编程的角度:

- 实现关系
- 泛化关系
- 依赖关系
- 组合关系 (组合关系+关联关系+聚合关系)

> 我们也没有必要去区分组合与聚合这两个概念,只需要记住一点就是: 多用组合少用继承 
>
> 也就是说只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系.

# 三、六大设计原则（SOLID）

## 1.设计原则概述

> 古人云: 有道无术,术可求.有术无道,止于术. 
>
> 而设计模式通常需要遵循一些设计原则，在设计原则的基础之上衍生出了各种各样的设计模式。设计原则是设计要求，设计模式是设计方案，使用设计模式的代码则是具体的实现。

设计模式中主要有六大设计原则，简称为SOLID ，是由于各个原则的首字母简称合并的来(两个L算一个,solid 稳定的)，六大设计原则分别如下：

**1、单一职责原则（Single Responsibitity Principle）**

**2、开放封闭原则（Open Close Principle）**

**3、里氏替换原则（Liskov Substitution Principle）**

**4、接口分离原则（Interface Segregation Principle）**

**5、依赖倒置原则（Dependence Inversion Principle）**

**6、迪米特法则（Law Of Demter）**

软件开发中我们要基于这六个原则,设计建立稳定、灵活、健壮的程序.

## 2.单一职责原则

### 2.1 官方定义

**单一职责原则**，英文缩写SRP，全称 Single Responsibility Principle。

在<<架构整洁之道>>一书中 关于这个原则的英文描述是这样的：A class or module should have a single responsibility 。如果我们把它翻译成中文，那就是**：一个类或者模块只负责完成一个职责（或者功能）**。

### 2.2 通俗解释

单一职责原则的定义描述非常简单，也不难理解。**一个类只负责完成一个职责或者功能。**

也就是说在类的设计中 我们不要设计大而全的类,而是要设计粒度小、功能单一的类. 

> 比如 我们设计一个类里面既包含了用户的一些操作,又包含了支付的一些操作,那这个类的职责就不够单一,应该将该类进行拆分,拆分成多个功能更加单一的,粒度更细的类.

### 2.3 场景示例

那么该如何判断一个类的职责是否单一 ?

> 其实在软件设计中，要真正用好单一职责原则并不简单，因为遵循这一原则最关键的地方在于职责的划分，而职责的划分是根据需求定的，同一个类（接口）的设计，在不同的需求里面，可能职责的划分并不一样.

我们来看下面这个例子:

在一个社交媒体产品中,我们使用 UserInfo 去记录用户的信息,包括如下的属性.

![image-20230806164131725](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806164131725.png)

请问上面的UserInfo类是否满足单一职责原则呢 ?

- 观点1: 满足,因为记录的都是跟用户相关的信息
- 观点2: 不满足,因为地址信息应该被拆分出来,单独放到地址表中保存.

正确答案: 根据实际业务场景选择是否拆分

- 该社交产品的有用户信息只是用来展示的,那么这个类这样设计就没有问题
- 假设后面这个社交产品又添加了电商模块, 那就需要将地址信息提取出来,单独设计一个类

![image-20230806164238420](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806164238420.png)

**总结: 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的,最好的方式就是:** 

> 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构

**如何判断一个类的职责是否单一?**

这里没有一个具体的金科玉律，但从实际代码开发经验上，有一些可执行性的侧面判断指标，可供参考：

- 类中的代码行数、函数、或者属性过多
- 类依赖的其他类过多
- 私有方法过多
- 类中大量的方法都是集中操作类中的几个属性

## 3.开闭原则

### 3.1 官方定义

一般认为最早提出开闭原则（Open-Close Principle，OCP）的是伯特兰·迈耶。他在1988 年发表的《面向对象软件构造》中给出的。在面向对象编程领域中，开闭原则规定软件中的对象、类、模块和函数对扩展应该是开放的，但对于修改是封闭的。这意味着应该用抽象定义结构，用具体实现扩展细节，以此确保软件系统开发和维护过程的可靠性。

### 3.2 通俗解释

定义：**对扩展开放，对修改关闭**

> 对扩展开放和对修改关闭表示当一个类或一个方法有新需求或者需求发生改变时应该采用扩展的方式而不应该采用修改原有逻辑的方式来实现。因为扩展了新的逻辑如果有问题只会影响新的业务，不会影响老业务；而如果采用修改的方式，很有可能就会影响到老业务受影响。
>
> 开闭原则是所有设计模式的最核心目标，也是最难实现的目标，但是所有的软件设计模式都应该以开闭原则当作标准，才能使软件更加的稳定和健壮。

优点：

1. 新老逻辑解耦，需求发生改变不会影响老业务的逻辑

2. 改动成本最小，只需要追加新逻辑，不需要改的老逻辑

3. 提供代码的稳定性和可扩展性

### 3.3 场景示例

系统A与系统B之间进行数据传输使用的是427版本的协议，一年以后对427版本的协议进行了修正。

设计时应该考虑的数据传输协议的可变性，抽象出具有报文解译、编制、校验等所有版本协议使用的通用方法，调用方针对接口进行编程即可，如上述示例设计类图如下

![image-20230806164939056](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230806164939056.png)

调用方依赖于报文接口，报文接口是稳定的，而不针对具体的427协议或427修正协议。利用接口多态技术，实现了开闭原则。

**顶层设计思维**

- 抽象意识
- 封装意识
- 扩展意识

> 在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整 体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩 展开放、对修改关闭”。

## 4.里氏替换原则

### 4.1 官方定义

里氏替换原则（Liskov Substitution Principle，LSP）是由麻省理工学院计算机科学系教授芭芭拉·利斯科夫于 1987 年在“面向对象技术的高峰会议”（OOPSLA）上发表的一篇论文《数据抽象和层次》（Data Abstractionand Hierarchy）里提出的.

她在论文中提到：如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。

> 子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

### 4.2 通俗解释

**如何理解里氏替换原则？**

要理解里氏替换原则，其实就是要理解两个问题：

- 什么是替换？
- 什么是与期望行为一致的替换（Robert Martin所说的“必须能够替换”）？

**1 ) 什么是替换 ?**

替换的前提是面向对象语言所支持的多态特性，同一个行为具有多个不同表现形式或形态的能力。

> 以JDK的集合框架为例，`List`接口的定义为有序集合，`List`接口有多个派生类，比如大家耳熟能详的`ArrayList`, `LinkedList`。那当某个方法参数或变量是`List`接口类型时，既可以是`ArrayList`的实现, 也可以是`LinkedList`的实现，这就是替换。

**2 ) 什么是与期望行为一致的替换？** 

在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派生类的实现，都与接口或基类方法的期望行为一致。

> 不需要关心是哪个类对接口进行了实现,因为不管底层如何实现,最终的结果都会符合接口中关于方法的描述(也就是与接口中方法的期望行为一致).
>
> 或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。

### 4.3 场景示例

里氏替换原则要求我们在编码时使用基类或接口去定义对象变量，使用时可以由具体实现对象进行赋值，实现变化的多样性，完成代码对修改的封闭，扩展的开放。

比如在一个商城项目中, 定义结算接口Istrategy，该接口有三个具体实现类，分别为 PromotionalStrategy （满减活动，两百以上百八折）、RebateStrategy （打折活动）、 ReduceStrategy（返现活动）

![](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/22.jpg)

```java
public interface Istrategy {
    public double realPrice(double consumePrice);
}

public class PromotionalStrategy implements Istrategy {
    public double realPrice(double consumePrice) {
        if (consumePrice > 200) {
            return 200 + (consumePrice - 200) * 0.8;
        } else {
            return consumePrice;
        }
    }
}
public class RebateStrategy implements Istrategy {
    private final double rate;
    public RebateStrategy() {
        this.rate = 0.8;
    }
    public double realPrice(double consumePrice) {
        return consumePrice * this.rate;
    }
}
public class ReduceStrategy implements Istrategy {
    public double realPrice(double consumePrice) {
        if (consumePrice >= 1000) {
            return consumePrice - 200;
        } else {
            return consumePrice;
        }
    }
}
```

调用方为Context，在此类中使用接口定义了一个对象。

![image-20230807144856354](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230807144856354.png)

```java
public class Context {
    //使用基类定义对象变量
    private Istrategy strategy;
    // 注入当前活动使用的具体对象
    public void setStrategy(Istrategy strategy) {
        this.strategy = strategy;
    }
    // 计算并返回费用
    public double cul(double consumePrice) {
        // 使用具体商品促销策略获得实际消费金额
        double realPrice = this.strategy.realPrice(consumePrice);
        // 格式化保留小数点后1位，即：精确到角
        BigDecimal bd = new BigDecimal(realPrice);
        bd = bd.setScale(1, BigDecimal.ROUND_DOWN);
        return bd.doubleValue();
    }
}
```

Context 中代码使用接口定义对象变量，这个对象变量可以是实现了 lStrategy 接口的 PromotionalStrategy、RebateStrategy 、 ReduceStrategy 任意一个。

里氏代换原则与多态的区别 ?

> 虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

里氏替换原则和依赖倒置原则，构成了面向接口编程的基础，正因为里氏替换原则，才使得程序呈现多样性。

## 5.接口隔离原则

### 5.1 官方定义

<<代码整洁之道>>作者**罗伯特 C·马丁** 为 “接口隔离原则” 的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。

该原则还有另外一个定义：一**个类对另一个类的依赖应该建立在最小的接口上**

### 5.2 通俗解释

上面两个定义的含义用一句话概括就是：**要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。** 

**接口隔离原则与单一职责原则的区别**

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

### 5.3 场景示例

微服务用户系统提供了一组跟用户相关的 API 给其他系统 使用，比如：注册、登录、获取用户信息等。

![image-20230807155530474](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230807155530474.png)

```java
public interface UserService {
    boolean register(String cellphone, String password);
    boolean login(String cellphone, String password);
    UserInfo getUserInfoById(long id);
    UserInfo getUserInfoByCellphone(String cellphone);
}

public class UserServiceImpl implements UserService {
		//...
}
```

> 需求: 后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口,应该如何设计这个接口(假设这里我们不去考虑使用鉴权框架).

- 方案1: 直接在UserService接口中添加一个删除用户的接口

> 这个方法可以解决问题，但是也隐藏了一些安全隐患。删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 UserService 中，那所有使用到 UserService 
> 的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。

- 方案2: 遵照接口隔离原则,为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法

> 将删除接口单独放到另外 一个接口 RestrictedUserService 中, 然后将 RestrictedUserService 只打包提供给后台管理系统来使用

![image-20230807155707019](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230807155707019.png)

```java
public interface UserService {
    boolean register(String cellphone, String password);
    boolean login(String cellphone, String password);
    UserInfo getUserInfoById(long id);
    UserInfo getUserInfoByCellphone(String cellphone);
}

public interface RestrictedUserService {
 boolean deleteUserByCellphone(String cellphone);
 boolean deleteUserById(long id);
}

public class UserServiceImpl implements UserService, RestrictedUserService {
		//...
}
```

## 6.依赖倒置原则

### 6.1 官方定义

依赖倒置原则是 Robert C.Martin 于1996年在 C++Report 上发表的文章中提出的

> High level modules should not depend upon low level modules. Both should depend upon abstractions.
> Abstractions should not depend upon details. Details should depend upon abstractions

依赖倒置原则（Dependence Inversion Principle，DIP）是指在设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

### 6.2 通俗解释

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合

1. 高层级的模块应该依赖的是低层级的模块的行为的抽象，取决于具体编程语言，可以是抽象类或者接口等技术；
2. 第2句话其实很简单，只有一个意思：只要依赖了实现，就是耦合了代码，所以我们需要始终依赖的是抽象，而不是实现；

- **传统的自定向下的设计**

传统设计方式采用自顶向下的原则， 逐级依赖，中层模块和高层模块的耦合度很高，如果需要修改其中的一个模块，则可能会导致其它很多模块也需要修改，牵一发动全身，不易于维护。

不使用依赖反转的系统构架，控制流和依赖关系流的依赖箭头是一个方向的，由高层指向底层，也就是高层依赖底层

![image-20230809121938056](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230809121938056.png)

- **依赖倒置原则**

> 依赖倒置原则的好处:
>
> - 减少类间的耦合性，提高系统的稳定性 . (根据类与类之间的耦合度从弱到强排列：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系 )
> - 降低并行开发引起的风险 (两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）就可以独立开发了)
> - 提高代码的可读性和可维护性

![image-20230809122029293](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230809122029293.png)

### 6.3 场景示例

假设我们现在要组装一台电脑,需要的配件有 cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。

![image-20230809122049426](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230809122049426.png)

**希捷硬盘类（XiJieHardDisk）:**

```java
public class XiJieHardDisk implements HardDisk {

    public void save(String data) {
        System.out.println("使用希捷硬盘存储数据" + data);
    }

    public String get() {
        System.out.println("使用希捷希捷硬盘取数据");
        return "数据";
    }
}
```

**Intel处理器（IntelCpu）：**

```java
public class IntelCpu implements Cpu {

    public void run() {
        System.out.println("使用Intel处理器");
    }
}
```

**金士顿内存条（KingstonMemory）：**

```java
public class KingstonMemory implements Memory {

    public void save() {
        System.out.println("使用金士顿作为内存条");
    }
}
```

**电脑（Computer）：**

```java
public class Computer {

    private XiJieHardDisk hardDisk;
    private IntelCpu cpu;
    private KingstonMemory memory;

    public IntelCpu getCpu() {
        return cpu;
    }

    public void setCpu(IntelCpu cpu) {
        this.cpu = cpu;
    }

    public KingstonMemory getMemory() {
        return memory;
    }

    public void setMemory(KingstonMemory memory) {
        this.memory = memory;
    }

    public XiJieHardDisk getHardDisk() {
        return hardDisk;
    }

    public void setHardDisk(XiJieHardDisk hardDisk) {
        this.hardDisk = hardDisk;
    }

    public void run() {
        System.out.println("计算机工作");
        cpu.run();
        memory.save();
        String data = hardDisk.get();
        System.out.println("从硬盘中获取的数据为：" + data);
    }
}
```

**测试类（TestComputer）：**

测试类用来组装电脑

```java
public class TestComputer {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.setHardDisk(new XiJieHardDisk());
        computer.setCpu(new IntelCpu());
        computer.setMemory(new KingstonMemory());

        computer.run();
    }
}
```

上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。

根据依赖倒转原则进行改进：

代码我们需要修改Computer类，让 Computer 类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类

**类图如下：**

![image-20230809122256880](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230809122256880.png)

**电脑（Computer）：**

```java
public class Computer {

    private HardDisk hardDisk;
    private Cpu cpu;
    private Memory memory;
	
    //getter/setter......
    
    public void run() {
        System.out.println("计算机工作");
    }
}
```

**关于依赖倒置、依赖注入、控制反转这三者之间的区别与联系**   

1 )  依赖倒置原则

依赖倒置是一种通用的软件设计原则, 主要用来指导框架层面的设计。

> 高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

2 ) 控制反转

控制反转与依赖倒置有一些相似, 它也是一种框架设计常用的模式,但并不是具体的方法。

> “控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。
>
> Spring框架，核心模块IoC容器,就是通过控制反转这一种思想进行设计的

3 ) 依赖注入

依赖注入是实现控制反转的一个手段，它是一种具体的编码技巧。

> 我们不通过 new 的方式在类内部创建依赖的对象，而是将依赖的对象在外部创建好之后，通过构造函数等方式传递（或注入）进来, 给类来使用。
>
> 依赖注入真正实现了面向接口编程的愿景，可以很方便地替换同一接口的不同实现，而不会影响到依赖这个接口的客户端。

## 7.迪米特法则

### 7.1 官方定义

1987年秋天，迪米特法则由美国Northeastern University的Ian Holland(伊恩 霍兰德)提出，被UML的创始者之一Booch(布奇)等人普及。后来，因为经典著作The PragmaticProgrammer <<程序员修炼之道>>而广为人知。

迪米特法则（LoD：Law of Demeter）又叫最少知识原则（LKP：Least Knowledge Principle ），指的是一个类/模块对其他的类/模块有越少的了解越好。简言之：talk only to your immediate friends（只跟你最亲密的朋友交谈），不跟陌生人说话。

### 7.2 通俗解释

大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到 实际的开发中，需要有实战经验的积累。迪米特法则也不例外。

简单来说迪米特法则想要表达的思想就是:  **不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。**

> 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

### 7.3 场景示例

我们一起来看下面这个例子: 

明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则

![image-20230809122746707](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230809122746707.png)

> 迪米特法则的独特之处在于它简洁而准确的定义，它允许在编写代码时直接应用，几乎自动地应用了适当的封装、高内聚和低耦合。
>
> 但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

**明星类（Star）**

```java
public class Star {
    private String name;

    public Star(String name) {
        this.name=name;
    }

    public String getName() {
        return name;
    }
}
```

**粉丝类（Fans）**

```java
public class Fans {
    private String name;

    public Fans(String name) {
        this.name=name;
    }

    public String getName() {
        return name;
    }
}
```

**媒体公司类（Company）**

```java
public class Company {
    private String name;

    public Company(String name) {
        this.name=name;
    }

    public String getName() {
        return name;
    }
}
```

**经纪人类（Agent）**

```java
public class Agent {
    private Star star;
    private Fans fans;
    private Company company;

    public void setStar(Star star) {
        this.star = star;
    }

    public void setFans(Fans fans) {
        this.fans = fans;
    }

    public void setCompany(Company company) {
        this.company = company;
    }

    public void meeting() {
        System.out.println(fans.getName() + "与明星" + star.getName() + "见面了。");
    }

    public void business() {
        System.out.println(company.getName() + "与明星" + star.getName() + "洽淡业务。");
    }
}
```

## 8.设计原则总结

我们之前给的大家介绍了评判代码质量的标准,比如可读性、可复用性、可扩展性等等,这是从代码的整体质量的角度来评判.

而设计原则就是我们要使用到的更加具体的对于代码进行评判的标准,比如, 我们说这段代码的可扩展性比较差，主要原因是违背了开闭原则。

我们所学习的SOLID 原则它包含了：

1. 单一职责原则（SRP）
2. 开闭原则（OCP）
3. 里氏替换原则（LSP）
4. 接口隔离原则（ISP）
5. 依赖倒置原则（DIP）
6. 迪米特法则 (LKP)

这里我们只需要重点关注三个常用的原则即可:

**1 ) 单一职责原则**

单一职责原则是类职责划分的重要参考依据，是保证代码”高内聚“的有效手段，是我们在进行面向对象设计时的主要指导原则。

> 单一职责原则的难点在于，对代码职责是否足够单一的判定。这要根据具体的场景来具体分析。同一个类的设计，在不同的场景下，对职责是否单一的判定，可能是不同的。

**2 ) 开闭原则**

开闭原则是保证代码可扩展性的重要指导原则，是对代码扩展性的具体解读。很多设计模式诞生的初衷都是为了提高代码的扩展性，都是以满足开闭原则为设计目的的。

> 开闭原则是所有设计模式的最核心目标，也是最难实现的目标，但是所有的软件设计模式都应该以开闭原则当作标准，才能使软件更加的稳定和健壮。

**3 ) 依赖倒置原则**

依赖倒置原则主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。

> 依赖倒置原则其实也是实现开闭原则的重要途径之一，它降低了类之间的耦合，提高了系统的稳定性和可维护性，同时这样的代码一般更易读，且便于传承。

# 四、创建型模式（5种）

创建型模式提供创建对象的机制,能够提升已有代码的灵活性和复用性

- 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。 


- 不常用的有：原型模式。

## 1.单例模式

### 1.1 单例模式介绍

**1 ) 定义**

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为单例类。

> 单例模式也比较好理解，比如一个人一生当中只能有一个真实的身份证号，一个国家只有一个政府，类似的场景都是属于单例模式。

**2 ) 使用单例模式要做的两件事**

1. 保证一个类只有一个实例
2. 为该实例提供一个全局访问节点

**3 ) 单例模式结构**

![image-20230809123422809](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230809123422809.png)

### 1.2 饿汉式（线程安全）

在类加载期间初始化静态实例,保证 instance 实例的创建是线程安全的 ( 实例在类加载时实例化，有JVM保证线程安全).

特点: 不支持延迟加载实例(懒加载) , 此中方式类加载比较慢，但是获取实例对象比较快

问题: 该对象足够大的话，而一直没有使用就会造成内存的浪费。

```java
public class Singleton_01 {
    // 1.私有构造方法
    private Singleton_01(){}

    // 2.在本类中创建私有静态的全局对象
    private static Singleton_01 instance = new Singleton_01();

    // 3.提供一个全局访问点，供外部获取单例实例
    public static Singleton_01 getInstance(){
        return instance;
    }
}
```

### 1.3 懒汉式（线程不安全）

此种方式的单例实现了懒加载，只有调用getInstance方法时才创建对象。但是如果是多线程情况，会出现线程安全问题。

```java
public class Singleton_02 {

    /**
     * 1.私有构造方法
     */
    private Singleton_02() {
    }

    /**
     * 2.在本类中创建私有静态的全局对象
     */
    private static Singleton_02 instance;

    /**
     * 3.通过判断对象是否被初始化，来选择是否创建对象
     */
    public static Singleton_02 getInstance() {
        // instance为空去创建实例对象，初始化实例对象
        if (instance == null) {
            instance = new Singleton_02();
        }
        return instance;
    }
}
```

> 假设在单例类被实例化之前，有两个线程同时在获取单例对象，线程A在执行完if (instance == null) 后，线程调度机制将 CPU 资源分配给线程B，此时线程B在执行 if (instance == null)时也发现单例类还没有被实例化，这样就会导致单例类被实例化两次。为了防止这种情况发生，需要对 getInstance() 方法同步处理。改进后的懒汉模式.

### 1.4 懒汉式（线程安全）

原理: 使用同步锁 `synchronized` 锁住 创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建

1. 即，`getInstance（）`方法块只能运行在1个线程中
2. 若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则会被阻塞，一直等待
3. 而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下 单例对象的唯一性

```java
public class Singleton_03 {

    /**
     * 1.私有构造方法
     */
    private Singleton_03() {
    }

    /**
     * 2.在本类中创建私有静态的全局对象
     */
    private static Singleton_03 instance;

    /**
     * 3.通过添加synchronized保证多线程模式下的单例对象的唯一性
     */
    public static synchronized Singleton_03 getInstance() {
        // instance为空去创建实例对象，初始化实例对象
        if (instance == null) {
            instance = new Singleton_03();
        }
        return instance;
    }
}
```

> 懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。

### 1.5 双重校验

饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。

实现步骤:

（1）在声明变量时使用了 volatile 关键字,其作用有两个: 

​	**保证变量的可见性**：当一个被 volatile 关键字修饰的变量被一个线程修改的时候，其他线程可以立刻得到修改之后的结果

​	**屏蔽指令重排序**：指令重排序是编译器和处理器为了高效对程序进行优化的手段，它只能保证程序执行的结果时正确的，但是无法保证程序的操作顺序与代码顺序一致。这在单线程中不会构成问题，但是在多线程中就会出现问题。

（2）将同步方法改为同步代码块. 在同步代码块中使用二次检查，以保证其不被重复实例化 同时在调用 getInstance() 方法时不进行同步锁，效率高。

```java
/**
 * 单例模式-双重校验
 */
public class Singleton_04 {
    /**
     * 1.私有构造方法
     */
    private Singleton_04() {
    }

    /**
     * 2.在本类中创建私有静态的全局对象
     * volatile：保证变量可见性，屏蔽指令重排序
     */
    private volatile static Singleton_04 instance;

    /**
     * 3.获取单例对象的静态方法
     */
    public static synchronized Singleton_04 getInstance() {
        // 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例
        if (instance == null) {
            synchronized (Singleton_04.class) {
                // 第二次判断，抢到锁之后再次进行判断，判断是否为null
                if (instance == null) {
                    instance = new Singleton_04();
                    /*
                        上面的创建对象代码中，在JVM会被分为三步：
                            1.分配内存空间
                            2.初始化对象
                            3.将instance指向分配好的内存空间
                        但是这一步会出现一个问题，JVM可能会对上面的步骤进行指令重排序
                        解决办法：添加 volatile 关键字
                     */
                }
            }
        }
        return instance;
    }
}
```

**在双重检查锁模式中为什么需要使用 volatile 关键字?**

在java内存模型中，volatile 关键字作用可以是保证可见性或者禁止指令重排。这里是因为 singleton = new Singleton() ，它并非是一个原子操作，事实上，在 JVM 中上述语句至少做了以下这 3 件事：

- 第一步是给 singleton 分配内存空间；
- 第二步开始调用 Singleton 的构造函数等，来初始化 singleton；
- 第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）;

这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。

如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错.

详细流程如下图所示：

![image-20230810124917298](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230810124917298.png)

线程 1 首先执行新建实例的第一步，也就是分配单例对象的内存空间，由于线程 1 被重排序，所以执行了新建实例的第三步，也就是把 singleton 指向之前分配出来的内存地址，在这第三步执行之后，singleton 对象便不再是 null。

这时线程 2 进入 getInstance 方法，判断 singleton 对象不是 null，紧接着线程 2 就返回 singleton 对象并使用，由于没有初始化，所以报错了。最后，线程 1 “姗姗来迟”，才开始执行新建实例的第二步——初始化对象，可是这时的初始化已经晚了，因为前面已经报错了。

使用了 volatile 之后，相当于是表明了该字段的更新可能是在其他线程中发生的，因此应确保在读取另一个线程写入的值时，可以顺利执行接下来所需的操作。在 JDK 5 以及后续版本所使用的 JMM 中，在使用了 volatile 后，会一定程度禁止相关语句的重排序，从而避免了上述由于重排序所导致的读取到不完整对象的问题的发生。

### 1.6 静态内部类

原理：根据 **静态内部类** 的特性(外部类的加载不影响内部类)，同时解决了按需加载、线程安全的问题，同时实现简洁

> 1. 在静态内部类里创建单例，在装载该内部类时才会去创建单例
> 2. 线程安全：类是由 `JVM`加载，而`JVM`只会加载1遍，保证只有1个单例

```java
public class Singleton_05 {

    private static class SingletonHandler{
        private static Singleton_05 instance = new Singleton_05();
    }

    private Singleton_05(){}

    public static Singleton_05 getInstance(){
        return SingletonHandler.instance;
    }
}
```

### 1.7 反射对于单例的破坏

> 反射的概念: JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

反射技术过于强大，它可以通过 `setAccessible()` 来修改构造器，字段，方法的可见性。单例模式的构造方法是私有的，如果将其可见性设为`public`，那么将无法控制对象的创建。

```java
public class Test_Reflect {

    public static void main(String[] args) {

        try {
            
            //反射中，欲获取一个类或者调用某个类的方法，首先要获取到该类的Class 对象。
            Class<Singleton_05> clazz = Singleton_05.class;

            //getDeclaredXxx: 不受权限控制的获取类的成员.
            Constructor c = clazz.getDeclaredConstructor(null);

            //设置为true,就可以对类中的私有成员进行操作了
            c.setAccessible(true);

            Object instance1 = c.newInstance();
            Object instance2 = c.newInstance();
			
            // false
            System.out.println(instance1 == instance2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

解决方法之一: 在单例类的构造方法中 添加判断 `instance != null` 时,直接抛出异常

```java
public class Singleton_05 {

    private static class SingletonHandler{
        private static Singleton_05 instance = new Singleton_05();
    }

    private Singleton_05(){
        if(SingletonHandler.instance != null){
            throw new RuntimeException("不允许非法访问!");
        }
    }

    public static Singleton_05 getInstance(){
        return SingletonHandler.instance;
    }
}
```

上面的这种方式使代码简洁性遭到破坏,设计不够优雅.

### 1.8 序列化对于单例的破坏

```java
/**
 * 序列化对单例的破坏
 * @author spikeCong
 * @date 2022/9/6
 **/
public class Test_Serializable {

    @Test
    public void test() throws Exception{

        //序列化对象输出流
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile.obj"));
        oos.writeObject(Singleton.getInstance());

        //序列化对象输入流
        File file = new File("tempFile.obj");
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        Singleton Singleton = (Singleton) ois.readObject();

        System.out.println(Singleton);
        System.out.println(Singleton.getInstance());

        //判断是否是同一个对象
        System.out.println(Singleton.getInstance() == Singleton);//false

    }
}


/**
 * 单例类实现序列化接口
 */
class Singleton implements Serializable {

    private volatile static Singleton singleton;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

输出结果为 false 说明：

通过对Singleton的序列化与反序列化得到的对象是一个新的对象，这就`破坏了Singleton的单例性`。

> 解决方案

```java
/**
* 解决方案:只要在Singleton类中定义readResolve就可以解决该问题
* 程序会判断是否有readResolve方法,如果存在就在执行该方法,如果不存在--就创建一个对象
*/
private Object readResolve() {
	return singleton;
}
```

问题是出在 `ObjectInputputStream` 的 `readObject` 方法上, 我们来看一下 `ObjectInputStream` 的 `readObject` 的调用栈:

![image-20230810141424148](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230810141424148.png)

`ObjectInputStream` 中 `readObject` 方法的代码片段

```java
try {
    Object obj = readObject0(false); // 最终会返回一个object对象,其实就是序列化对象
    return obj;
} finally {
    passHandle = outerHandle;
    if (closed && depth == 0) {
        clear();
    }
}
```

`ObjectInputStream` 中 `readObject0` 方法的代码片段

```java
private Object readObject0(boolean unshared) throws IOException {

    case TC_OBJECT: // 匹配如果是对象
        return checkResolve(readOrdinaryObject(unshared));
}
```

`readOrdinaryObject` 方法的代码片段

```java
private Object readOrdinaryObject(boolean unshared) throws IOException {
    // 此处省略部分代码

    Object obj;
    try {
        // 通过反射创建的这个obj对象，就是本方法要返回的对象，也可以暂时理解为是 ObjectInputStream 的 readObject 返回的对象。
        // isInstantiable：如果一个serializable的类可以在运行时被实例化，那么该方法就返回true
        // desc.newInstance：该方法通过反射的方式调用无参构造方法新建一个对象。
        obj = desc.isInstantiable() ? desc.newInstance() : null;
    } catch (Exception ex) {
        throw (IOException) new InvalidClassException(
            desc.forClass().getName(),
            "unable to create instance").initCause(ex);
    }

    return obj;
}
```

- 到目前为止，也就可以解释，为什么序列化可以破坏单例了:?


答: 序列化会通过反射调用无参数的构造方法创建一个新的对象。

- 如何解决呢?


答: 只要在Singleton类中定义readResolve就可以解决该问题

```java
// 只要在Singleton类中定义readResolve就可以解决该问题
private Object readResolve() {
	return singleton;
}
```

实现原理

```java
if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) {
    
    Object rep = desc.invokeReadResolve(obj);
    
    if (unshared && rep.getClass().isArray()) {
        rep = cloneArray(rep);
    }
    
    if (rep != obj) {
        handles.setObject(passHandle, obj = rep);
    }
}
```

`hasReadResolveMethod`:如果实现了serializable 接口的类中包含readResolve则返回true

`invokeReadResolve`:通过反射的方式调用要被反序列化类的readResolve方法。

**总结: Singleton中定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。**

### 1.9 枚举（推荐方式）

枚举单例方式是`<<Effective Java>>`作者推荐的使用方式,这种方式

> 在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例；默认枚举实例的创建是线程安全的，即使反序列化也不会生成新的实例，任何情况下都是一个单例(暴力反射对枚举方式无效)。

特点: 满足单例模式所需的 **创建单例、线程安全、实现简洁的需求** 

```java
public enum Singleton_06{

    INSTANCE;

    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static Singleton_06 getInstance(){

        return INSTANCE;
    }
}
```

**问题1: 为什么枚举类可以阻止反射的破坏?**

1. 首先枚举类中是没有空参构造方法的,只有一个带两个参数的构造方法.

   ![image-20230810143036451.png](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230810143036451.png)

2. 真正原因是: 反射方法中不予许使用反射创建枚举对象

> 异常: 不能使用反射方式创建enum对象

![image-20230810150237992](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230810150237992.png)

**问题2: 为什么枚举类可以阻止序列化的破坏?**

Java规范字规定，每个枚举类型及其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。

在序列化的时候Java仅仅是将枚举对象的name属性输到结果中，反序列化的时候则是通过java.lang.Enum的valueOf()方法来根据名字查找枚举对象。

比如说，序列化的时候只将`INSTANCE`这个名称输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。

```java
public enum Singleton_06{
    INSTANCE;
}
```

### 2.0 单例模式总结

**1 ) 单例的定义**

单例设计模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为单例类。

**2 ) 单例的实现**

**饿汉式**

- 饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。

**懒汉式**

- 相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。

**双重检测**

- 双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。

**静态内部类**

- 利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。

**枚举方式**

- 最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性(同时阻止了反射和序列化对单例的破坏)。

## 2.工厂方法模式

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

> 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

《设计模式》一书中，工厂模式被分为了三种：简单工厂、工厂方法和抽象工厂。（不过，在书中作者将简单工厂模式看作是工厂方法模式的一种特例。）

* 简单工厂模式（不属于GOF的23种经典设计模式）
* 工厂方法模式
* 抽象工厂模式

### 2.1 需求: 模拟发放奖品业务

需求: 为了让我们的案例更加贴近实际开发, 这里我们来模拟一下互联网电商中促销拉新下的业务场景, **新用户注册立即参与抽奖活动** ,奖品的种类有: 打折券, 免费优酷会员,小礼品.

### 2.2 原始开发方式

**不考虑设计原则,不使用设计模式的方式进行开发** 

在不考虑任何代码的可扩展性的前提下,只为了尽快满足需求.我们可以这样去设计这个业务的代码结构:

**1) 实体类**

| 名称           | 描述                     |
| -------------- | ------------------------ |
| AwardInfo      | 获奖信息对应实体类       |
| DiscountInfo   | 打折券信息对应实体       |
| YouKuMember    | 优酷会员对应实体类       |
| SmallGiftInfo  | 小礼品信息对应实体类     |
| DiscountResult | 打折券操作响应结果封装类 |

```java
public class AwardInfo {

    private String uid; //用户唯一ID

    private Integer awardType; //奖品类型: 1 打折券 ,2 优酷会员,3 小礼品

    private String awardNumber; //奖品编号

    Map<String, String> extMap; //额外信息
    
}

public class DiscountInfo {

    //属性信息省略......
}

public class YouKuMember {

    //属性信息省略......
}

public class SmallGiftInfo {

    private String userName;              // 用户姓名
    private String userPhone;             // 用户手机
    private String orderId;               // 订单ID
    private String relAddress;            // 收货地址
    
}

public class DiscountResult {

    private String status; // 状态码
    private String message; // 信息
}
```

**2）服务层**

| 名称               | 功能                                                  | 描述                 |
| ------------------ | ----------------------------------------------------- | -------------------- |
| DiscountService    | DiscountResult sendDiscount(String uid,String number) | 模拟打折券服务       |
| YouKuMemberService | void openMember(String bindMobile , String number)    | 模拟赠送优酷会员服务 |
| SmallGiftService   | Boolean giveSmallGift(SmallGiftInfo smallGiftInfo)    | 模拟礼品服务         |

```java
public class DiscountService {

    public DiscountResult sendDiscount(String uid, String number){

        System.out.println("向用户发放打折券一张: " + uid + " , " + number);
        return new DiscountResult("200","发放打折券成功");
    }
}

public class YouKuMemberService {

    public void openMember(String bindMobile , String number){

        System.out.println("发放优酷会员: " + bindMobile + " , " + number);
    }
}

public class SmallGiftService {

    public Boolean giveSmallGift(SmallGiftInfo smallGiftInfo){

        System.out.println("小礼品已发货,获奖用户注意查收! " + JSON.toJSON(smallGiftInfo));
        return true;
    }
}
```

**3) 控制层**

| 名称              | 功能                                            | 描述                                                         |
| ----------------- | ----------------------------------------------- | ------------------------------------------------------------ |
| DeliverController | ResponseResult awardToUser(AwardInfo awardInfo) | 按照类型的不同发放商品<br />奖品类型: 1 打折券 ,2 优酷会员,3 小礼品 |

```java
public class DeliverController {

    /**
     * 按照类型的不同发放商品
     *     奖品类型: 1 打折券 ,2 优酷会员,3 小礼品
     */
    public void awardToUser(AwardInfo awardInfo){

        if(awardInfo.getAwardType() == 1){ //打折券
            DiscountService discountService = new DiscountService();
            DiscountResult result = discountService.sendDiscount(awardInfo.getUid(), awardInfo.getAwardNumber());
            System.out.println("打折券发放成功!"+ JSON.toJSON(result));

        }else if(awardInfo.getAwardType() == 2){ //优酷会员
            //获取用户手机号
            String bindMobile = awardInfo.getExtMap().get("phone");

            //调用service
            YouKuMemberService youKuMemberService = new YouKuMemberService();
            youKuMemberService.openMember(bindMobile,awardInfo.getAwardNumber());
            System.out.println("优酷会员发放成功!");

        }else if(awardInfo.getAwardType() == 3){ /*
            小礼品
            封装收货用户信息
            */
            SmallGiftInfo smallGiftInfo = new SmallGiftInfo();
            smallGiftInfo.setUserName(awardInfo.getExtMap().get("username"));
            smallGiftInfo.setOrderId(UUID.randomUUID().toString());
            smallGiftInfo.setRelAddress(awardInfo.getExtMap().get("adderss"));

            SmallGiftService smallGiftService = new SmallGiftService();
            Boolean isSuccess = smallGiftService.giveSmallGift(smallGiftInfo);
            System.out.println("小礼品发放成功!" + isSuccess);
        }
    }

}
```

**4) 测试**

通过单元测试,来对上面的接口进行测试,验证代码质量.

```java
public class TestApi01 {

    //测试发放奖品接口
    @Test
    public void test01(){

        DeliverController deliverController = new DeliverController();

        //1. 发放打折券优惠
        AwardInfo info1 = new AwardInfo();
        info1.setUid("1001");
        info1.setAwardType(1);
        info1.setAwardNumber("DEL12345");

        deliverController.awardToUser(info1);

        //2. 发放优酷会员
        AwardInfo info2 = new AwardInfo();
        info2.setUid("1002");
        info2.setAwardType(2);
        info2.setAwardNumber("DW12345");
        Map<String,String> map = new HashMap<>();
        map.put("phone","13512341234");
        info2.setExtMap(map);

        deliverController.awardToUser(info2);

        //2. 发放小礼品
        AwardInfo info3 = new AwardInfo();
        info3.setUid("1003");
        info3.setAwardType(3);
        info3.setAwardNumber("SM12345");
        Map<String,String> map2 = new HashMap<>();
        map2.put("username","大远");
        map2.put("phone","13512341234");
        map2.put("address","北京天安门");
        info3.setExtMap(map2);

        deliverController.awardToUser(info3);
    }
}
```

> 对于上面的实现方式,如果我们有想要添加的新的奖品时,势必要改动 DeliverController 的代码,违反开闭原则.而且如果有的抽奖接口出现问题,那么对其进行重构的成本会非常高.
>
> 除此之外代码中有一组if分支判断逻辑,现在看起来还可以,但是如果经历几次迭代和拓展,后续ifelse肯定还会增加.到时候接手这段代码的研发将会十分痛苦.

### 2.3 简单工厂模式

#### 2.3.1 简单工厂模式介绍

简单工厂不是一种设计模式，反而比较像是一种编程习惯。简单工厂模式又叫做静态工厂方法模式（static Factory Method pattern）,它是通过使用静态方法接收不同的参数来返回不同的实例对象.

**实现方式:**  

> 定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。

**适用场景：**

　　（1）需要创建的对象较少

　　（2）客户端不关心对象的创建过程

#### 2.3.2 简单工厂原理

简单工厂包含如下角色：

* 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能
* 具体产品 ：实现或者继承抽象产品的子类
* 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品

![image-20230816162104876](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230816162104876.png)

#### 2.3.3 简单工厂模式重构代码

**1) service** 

```java
/**
 * 免费商品发放接口
 * @author spikeCong
 * @date 2022/9/8
 **/
public interface IFreeGoods {
    ResponseResult sendFreeGoods(AwardInfo awardInfo);
}
```

```java
/**
 * 模拟打折券服务
 * @author spikeCong
 * @date 2022/9/8
 **/
public class DiscountFreeGoods implements IFreeGoods {

    @Override
    public ResponseResult sendFreeGoods(AwardInfo awardInfo) {

        System.out.println("向用户发放一张打折券: " + awardInfo.getUid() + " , " + awardInfo.getAwardNumber());
        return new ResponseResult("200","打折券发放成功!");
    }
}

/**
 * 小礼品发放服务
 * @author spikeCong
 * @date 2022/9/8
 **/
public class SmallGiftFreeGoods implements IFreeGoods {

    @Override
    public ResponseResult sendFreeGoods(AwardInfo awardInfo) {

        SmallGiftInfo smallGiftInfo = new SmallGiftInfo();
        smallGiftInfo.setUserPhone(awardInfo.getExtMap().get("phone"));
        smallGiftInfo.setUserName(awardInfo.getExtMap().get("username"));
        smallGiftInfo.setAddress(awardInfo.getExtMap().get("address"));
        smallGiftInfo.setOrderId(UUID.randomUUID().toString());

        System.out.println("小礼品发放成,请注意查收: " + JSON.toJSON(smallGiftInfo));
        return new ResponseResult("200","小礼品发送成功",smallGiftInfo);
    }
}

/**
 * 优酷 会员服务
 * @author spikeCong
 * @date 2022/9/8
 **/
public class YouKuMemberFreeGoods implements IFreeGoods {

    @Override
    public ResponseResult sendFreeGoods(AwardInfo awardInfo) {

        String phone = awardInfo.getExtMap().get("phone");
        System.out.println("发放优酷会员成功,绑定手机号: " + phone);
        return new ResponseResult("200","优酷会员发放成功!");
    }
}
```

**2) factory** 

```java
/**
 * 具体工厂: 生成免费商品
 * @author spikeCong
 * @date 2022/9/9
 **/
public class FreeGoodsFactory {

    public static IFreeGoods getInstance(Integer awardType){

        IFreeGoods iFreeGoods = null;

        if(awardType == 1){  //打折券
            iFreeGoods = new DiscountFreeGoods();
        }else if(awardType == 2){ //优酷会员
            iFreeGoods = new YouKuMemberFreeGoods();
        }else if(awardType == 3){ //小礼品
            iFreeGoods = new SmallGiftFreeGoods();
        }
        return iFreeGoods;
    }
}
```

**3）controller**

```java
public class DeliverController {

    //发放奖品
    public ResponseResult awardToUser(AwardInfo awardInfo){

        try {
            IFreeGoods freeGoods = FreeGoodsFactory.getInstance(awardInfo.getAwardTypes());
            ResponseResult responseResult = freeGoods.sendFreeGoods(awardInfo);
            return responseResult;
        } catch (Exception e) {
            e.printStackTrace();
            return new ResponseResult("201","奖品发放失败!");
        }
    }
}
```

**4) 测试** 

通过单元测试,来对上面的接口进行测试,验证代码质量.

```java
public class TestApi02 {

    DeliverController deliverController = new DeliverController();

    @Test
    public void test01(){

        //1. 发放打折券优惠
        AwardInfo info1 = new AwardInfo();
        info1.setUid("1001");
        info1.setAwardTypes(1);
        info1.setAwardNumber("DEL12345");

        ResponseResult result = deliverController.awardToUser(info1);
        System.out.println(result);

    }

    @Test
    public void test02(){

        //2. 发放优酷会员
        AwardInfo info2 = new AwardInfo();
        info2.setUid("1002");
        info2.setAwardTypes(2);
        info2.setAwardNumber("DW12345");
        Map<String,String> map = new HashMap<>();
        map.put("phone","13512341234");
        info2.setExtMap(map);

        ResponseResult result1 = deliverController.awardToUser(info2);
        System.out.println(result1);

    }

    @Test
    public void test03(){

        //3. 发放小礼品
        AwardInfo info3 = new AwardInfo();
        info3.setUid("1003");
        info3.setAwardTypes(3);
        info3.setAwardNumber("SM12345");
        Map<String,String> map2 = new HashMap<>();
        map2.put("username","大远");
        map2.put("phone","13512341234");
        map2.put("address","北京天安门");
        info3.setExtMap(map2);

        ResponseResult result2 = deliverController.awardToUser(info3);
        System.out.println(result2);
    }
}
```

#### 2.3.4 简单工厂模式总结

**优点：**

封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。

**缺点：**

增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。

### 2.4 工厂方法模式

#### 2.4.1 工厂方法模式介绍

工厂方法模式 `Factory Method pattern`,属于创建型模式. 

概念: 定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。

#### 2.4.2 工厂方法模式原理

工厂方法模式的目的很简单，就是**封装对象创建的过程，提升创建对象方法的可复用性**。

工厂方法模式的主要角色：

* 抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
* 具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
* 抽象产品：定义了产品的规范，描述了产品的主要特性和功能。
* 具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

我们直接来看看工厂方法模式的 UML 图：

![image-20230816162506156](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230816162506156.png)

#### 2.4.3 工厂方法模式重构代码

为了提高代码扩展性,我们需要将简单工厂中的if分支逻辑去掉,通过增加抽象工厂(**生产工厂的工厂**)的方式，让具体工厂去进行实现，由具体工厂来决定实例化哪一个具体的产品对象.

**抽象工厂**

```java
public interface FreeGoodsFactory {

    IFreeGoods getInstance();
}
```

**具体工厂**

```java
public class DiscountFreeGoodsFactory implements FreeGoodsFactory {

    @Override
    public IFreeGoods getInstance() {
        return new DiscountFreeGoods();
    }
}

public class SmallGiftFreeGoodsFactory implements FreeGoodsFactory {
    @Override
    public IFreeGoods getInstance() {

        return new SmallGiftFreeGoods();
    }
}
```

**Controller**

```java
public class DeliverController {

    /**
     * 按照类型的不同发放商品
     */
    public ResponseResult awardToUser(AwardInfo awardInfo){

        FreeGoodsFactory freeGoodsFactory = null;

        if(awardInfo.getAwardType() == 1){

            freeGoodsFactory = new DiscountFreeGoodsFactory();
        }else if(awardInfo.getAwardType() == 2){

            freeGoodsFactory = new SmallGiftFreeGoodsFactory();
        }

        IFreeGoods freeGoods = freeGoodsFactory.getInstance();

        System.out.println("=====工厂方法模式========");
        ResponseResult result = freeGoods.sendFreeGoods(awardInfo);

        return result;
    }

}
```

从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 awardToUser() 方法中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。

那怎么来解决这个问题呢？

我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。

```java
/**
 * 用简单方法模式实现: 工厂的工厂,作用是不需要每次创建新的工厂对象
 * @author spikeCong
 * @date 2022/9/9
 **/
public class FreeGoodsFactoryMap {

    private static final Map<Integer,FreeGoodsFactory> cachedFactories = new HashMap<>();

    static{
        cachedFactories.put(1, new DiscountFreeGoodsFactory());
        cachedFactories.put(2, new SmallGiftFreeGoodsFactory());
    }

    public static FreeGoodsFactory getParserFactory(Integer type){
        if(type == 1){
            FreeGoodsFactory freeGoodsFactory = cachedFactories.get(1);
            return freeGoodsFactory;
        }else if(type ==2){
            FreeGoodsFactory freeGoodsFactory = cachedFactories.get(2);
            return freeGoodsFactory;
        }

        return null;
    }
}
```

**Controller**

```java
/**
 * 发放奖品接口
 * @author spikeCong
 * @date 2022/9/7
 **/
public class DeliverController {

    /**
     * 按照类型的不同发放商品
     */
    public ResponseResult awardToUser(AwardInfo awardInfo){

        //根据类型获取工厂
        FreeGoodsFactory goodsFactory = FreeGoodsFactoryMap.getParserFactory(awardInfo.getAwardType());

        //从工厂中获取对应实例
        IFreeGoods freeGoods = goodsFactory.getInstance();

        System.out.println("=====工厂方法模式========");
        ResponseResult result = freeGoods.sendFreeGoods(awardInfo);
        return result;
    }
}
```

现在我们的代码已经基本上符合了开闭原则,当有新增的产品时,我们需要做的事情包括:

1. 创建新的产品类,并且让该产品实现抽象产品接口
2. 创建产品类对应的具体工厂,并让具体工厂实现抽象工厂
3. 将新的具体工厂对象,添加到 FreeGoodsFactoryMap 的 cachedFactories 中即可,需要改动的代码改动的非常少.

### 2.5 工厂方法模式总结

**优点：**

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；

**缺点：**

* 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。

**什么时候使用工厂方法模式**

- 需要使用很多重复代码创建对象时，比如，DAO 层的数据对象、API 层的 VO 对象等。
- 创建对象要访问外部信息或资源时，比如，读取数据库字段，获取访问授权 token 信息，配置文件等。
- 创建需要统一管理生命周期的对象时，比如，会话信息、用户网页浏览轨迹对象等。
- 创建池化对象时，比如，连接池对象、线程池对象、日志对象等。这些对象的特性是：有限、可重用，使用工厂方法模式可以有效节约资源。
- 希望隐藏对象的真实类型时，比如，不希望使用者知道对象的真实构造函数参数等。

## 3.抽象工厂模式

### 3.1 抽象工厂模式介绍

> 抽象工厂模式比工厂方法模式的抽象程度更高. 在工厂方法模式中每一个具体工厂只需要生产一种具体产品,但是在抽象工厂模式中一个具体工厂可以生产一组相关的具体产品,这样一组产品被称为产品族.产品族中的每一个产品都分属于某一个产品继承等级结构. 

**1) 产品等级结构与产品族** 

为了更好的理解抽象工厂, 我们这里先引入两个概念:

- **产品等级结构** ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。

- **产品族** ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

![image-20230816172425419](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230816172425419.png)

> 在上图中,每一个具体工厂可以生产属于一个产品族的所有产品,例如海尔工厂生产海尔电视机、海尔空调和海尔冰箱,所生产的产品又位于不同的产品等级结构中. 如果使用工厂方法模式,上图所示的结构需要提供9个具体工厂,而使用抽象工厂模式只需要提供3个具体工厂,极大减少了系统中类的个数.

**2) 抽象工厂模式概述**

抽象工厂模式(Abstract Factory Pattern)  原始定义：**提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。**

抽象工厂模式为创建一组对象提供了解决方案.与工厂方法模式相比,**抽象工厂模式中的具体工厂不只是创建一种产品,而是负责创建一个产品族**.如下图:

![image-20230816172501493](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230816172501493.png)

### 3.2 抽象工厂模式原理

在抽象工厂模式中,每一个具体工厂都提供了多个工厂方法,用于产生多种不同类型的产品.这些产品构成了一个产品族.

![image-20230816172537401](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230816172537401.png)

抽象工厂模式的主要角色如下：

* 抽象工厂（Abstract Factory）：它声明了一种用于创建一族产品的方法,每一个方法对应一种产品.
* 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建.
* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。

### 3.3 抽象工厂模式实现

**抽象工厂**

```java
/**
 * 抽象工厂: 在一个抽象工厂中可以声明多个工厂方法,用于创建不同类型的产品
 * @author spikeCong
 * @date 2022/9/15
 **/
public interface AppliancesFactory {

    AbstractTV createTV();

    AbstractFreezer createFreezer();
}
```

具体工厂: 每一个具体工厂方法,可以返回一个特定的产品对象,而同一个具体工厂所创建的产品对象构成了一个产品族.

```java
public class HairFactory implements AppliancesFactory {

    @Override
    public AbstractTV createTV() {
        return new HairTV();
    }

    @Override
    public AbstractFreezer createFreezer() {
        return new HairFreezer();
    }
}

public class HisenseFactory implements AppliancesFactory {

    @Override
    public AbstractTV createTV() {
        return new HisenseTV();
    }

    @Override
    public AbstractFreezer createFreezer() {
        return new HisenseFreezer();
    }
}
```

**抽象产品**

```java
public interface AbstractFreezer {}
public interface AbstractTV {}
```

**具体产品**

```java
public class HairFreezer implements AbstractFreezer {}
public class HisenseFreezer implements AbstractFreezer {}
public class HairTV implements AbstractTV {}
public class HisenseTV implements AbstractTV {}
```

**客户端**

```java
public class Client {

    private AbstractTV tv;

    private AbstractFreezer freezer;

    public Client(AppliancesFactory factory){

        //在客户端看来就是使用抽象工厂来生产家电
        this.tv = factory.createTV();
        this.freezer = factory.createFreezer();
    }

    public AbstractTV getTv() {
        return tv;
    }

    public void setTv(AbstractTV tv) {
        this.tv = tv;
    }

    public AbstractFreezer getFreezer() {
        return freezer;
    }

    public void setFreezer(AbstractFreezer freezer) {
        this.freezer = freezer;
    }

    public static void main(String[] args) {

        Client client = new Client(new HisenseFactory());
        AbstractTV tv = client.getTv();
        System.out.println(tv);

        AbstractFreezer freezer = client.getFreezer();
        System.out.println(freezer);
    }
}
```

### 3.4 抽象工厂模式总结

从上面代码实现中我们可以看出，抽象工厂模式向使用（客户）方隐藏了下列变化：

- 程序所支持的实例集合（具体工厂）的数目；
- 当前是使用的实例集合中的哪一个实例；
- 在任意给定时刻被实例化的具体类型；

所以说，在理解抽象工厂模式原理时，你一定要牢牢记住“如何找到某一个类产品的正确共性功能”这个重点。

**抽象工厂模式优点**

1) 对于不同产品系列有比较多共性特征时，可以使用抽象工厂模式，有助于提升组件的复用性.

2) 当需要提升代码的扩展性并降低维护成本时，把对象的创建和使用过程分开，能有效地将代码统一到一个级别上

3) 解决跨平台带来的兼容性问题

**抽象工厂模式缺点**

增加新的产品等级结构麻烦,需要对原有结构进行较大的修改,甚至需要修改抽象层代码,这显然会带来较大不变,违背了开闭原则.

## 4.建造者模式

### 4.1 建造者模式介绍

**建造者模式** (builder pattern), 也被称为**生成器模式** , 是一种创建型设计模式.

- 定义: 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。

**建造者模式要解决的问题 **

建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。

> 比如: 一辆汽车是由多个部件组成的,包括了车轮、方向盘、发动机等等.对于大多数用户而言,并不需要知道这些部件的装配细节,并且几乎不会使用单独某个部件,而是使用一辆完整的汽车.而建造者模式就是负责将这些部件进行组装让后将完整的汽车返回给用户.

![image-20230820135250247](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230820135250247.png)

### 4.2 建造者模式原理

建造者（Builder）模式包含以下4个角色 :

* 抽象建造者类（Builder）：这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建

* 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供一个方法,返回创建好``的负责产品对象

* 产品类（Product）：要创建的复杂对象 (包含多个组成部件)

* 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建(客户端一般只需要与指挥者进行交互)。

![image-20230822133307723](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230822133307723.png)

### 4.3 建造者模式实现方式1

**创建共享单车**

生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。

这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和HelloBuilder是具体的建造者；Director是指挥者。类图如下：

![image-20230822133514603](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230822133514603.png)

**具体产品**

```java
/**
 * 自行车类-产品类
 */
public class Bike {
    /**
     * 车架
     */
    private String frame;

    /**
     * 车座
     */
    private String seat;

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }
}
```

**抽象构建者类**

```java
/**
 * 抽象建造者类
 */
public abstract class Builder {
    /**
     * protected 只让子类去使用此Bike对象
     * 也就是给具体的建造者使用即可
     */
    protected Bike mBike = new Bike();

    /**
     * 创建车架抽象方法
     */
    public abstract void buildFrame();

    /**
     * 创建车座抽象方法
     */
    public abstract void buildSeat();

    /**
     * 返回创建好的Bike产品对象
     * @return Bike产品对象
     */
    public abstract Bike createBike();
}
```

**具体构建者类**

```java
/**
 * 摩拜单车建造者
 */
public class MoBikeBuilder extends Builder {
    @Override
    public void buildFrame() {
        System.out.println("制作车架！");
        super.mBike.setFrame("铝合金车架");
    }

    @Override
    public void buildSeat() {
        System.out.println("制作车座！");
        super.mBike.setSeat("真皮车座");
    }

    @Override
    public Bike createBike() {
        return super.mBike;
    }
}
```

```java
/**
 * 哈罗单车建造者
 */
public class HelloBikeBuilder extends Builder {
    @Override
    public void buildFrame() {
        System.out.println("制作碳纤维车架！");
        super.mBike.setFrame("碳纤维车架");
    }

    @Override
    public void buildSeat() {
        System.out.println("制作橡胶车座！");
        super.mBike.setSeat("橡胶车座");
    }

    @Override
    public Bike createBike() {
        return super.mBike;
    }
}

```

**指挥者类**

```java
/**
 * 指挥者类
 */
public class Director {
    /**
     * 创建Builder抽象
     */
    private Builder mBuilder;

    public Director(Builder mBuilder) {
        this.mBuilder = mBuilder;
    }

    /**
     * 自行车制作方法
     * @return Bike产品
     */
    public Bike construct() {
        mBuilder.buildFrame();
        mBuilder.buildSeat();
        return mBuilder.createBike();
    }
}
```

**客户端**

```java
/**
 * 客户端
 */
public class Client {
    public static void main(String[] args) {
        // 1.创建指挥者
        Director director = new Director(new HelloBikeBuilder());

        // 2.获取自行车
        Bike bike = director.construct();

        System.out.println(bike.getFrame() + "," + bike.getSeat());

    }
}
```

### 4.4 建造者模式实现方式2

建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。

**1 ) 构造方法创建复杂对象的问题**

构造方法如果参数过多,代码的可读性和易用性都会变差. 在使用构造函数时,很容易搞错参数的顺序,传递进去错误的参数值,导致很有隐蔽的BUG出现.

```java
/**
 * MQ连接客户端
 */
public class RabbitMQClient1 {

    private String host = "127.0.0.1";

    private int port = 5672;

    private int mode;

    private String exchange;

    private String queue;

    private boolean isDurable = true;

    int connectionTimeout = 1000;


    /**
     * 构造方法参数过多,代码的可读性和易用性太差,在使用构造函数时,很容易搞错顺序,传递错误的参数值,导致很有隐蔽的BUG
     */
    public RabbitMQClient1(String host, int port, int mode, String exchange, String queue, boolean isDurable, int connectionTimeout) {
        this.host = host;
        this.port = port;
        this.mode = mode;
        this.exchange = exchange;
        this.queue = queue;
        this.isDurable = isDurable;
        this.connectionTimeout = connectionTimeout;

        if(mode == 1){ //工作队列模式不需要设计交换机,但是队列名称一定要有
            if(exchange != null){
                throw new RuntimeException("工作队列模式无需设计交换机");
            }
            if(queue == null || queue.trim().equals("")){
                throw new RuntimeException("工作队列模式名称不能为空");
            }
            if(isDurable == false){
                throw new RuntimeException("工作队列模式必须开启持久化");
            }
        }else if(mode == 2){ //路由模式必须设计交换机,但是不能设计队列
            if(exchange == null){
                throw new RuntimeException("路由模式下必须设置交换机");
            }
            if(queue != null){
                throw new RuntimeException("路由模式无须设计队列名称");
            }
        }

        //其他验证方式,
    }

    public void sendMessage(String msg){

        System.out.println("发送消息......");
    }

    public static void main(String[] args) {
        // 每一种模式,都需要根据不同的情况进行实例化,构造方法会变得过于复杂.
        RabbitMQClient1 client1 = new RabbitMQClient1("192.168.52.123",5672,
                2,"sample-exchange",null,true,5000);

        client1.sendMessage("Test-MSG");
    }
}
```

**2) set方法创建复杂对象的问题** 

- set方式设置对象属性时,存在中间状态,并且属性校验时有前后顺序约束,逻辑校验的代码找不到合适的地方放置.

> 比如下面的代码,  创建对象后使用set 的方式，那就会导致在第一个 set 之后，对象处于无效状态
>
> Rectangle r = new Rectangle ();  //无效状态
>
> r.setWidth(2);  //无效状态
>
> r.setHeight(3);  //有效状态

- set方法还破坏了"不可变对象"的密闭性 

> 不可变对象:  对象创建好了,就不能再修改内部的属性值,下面的client类就是典型的不可变对象,创建好的连接对象不能再改动

```java
package org.example.example02;

/**
 * MQ连接客户端
 */
public class RabbitMQClient2 {
    private String host = "127.0.0.1";

    private int port = 5672;

    private int mode;

    private String exchange;

    private String queue;

    private boolean isDurable = true;

    int connectionTimeout = 1000;

    //私有化构造方法
    private RabbitMQClient2() {

    }

    public String getExchange() {
        return exchange;
    }

    public void setExchange(String exchange) {

        if(mode == 1){ //工作队列模式不需要设计交换机,但是队列名称一定要有
            if(exchange != null){
                throw new RuntimeException("工作队列模式无需设计交换机");
            }
            if(queue == null || queue.trim().equals("")){
                throw new RuntimeException("工作队列模式名称不能为空");
            }
            if(isDurable == false){
                throw new RuntimeException("工作队列模式必须开启持久化");
            }
        }else if(mode == 2){ //路由模式必须设计交换机,但是不能设计队列
            if(exchange == null){
                throw new RuntimeException("路由模式下必须设置交换机");
            }
            if(queue != null){
                throw new RuntimeException("路由模式无须设计队列名称");
            }
        }

        //其他验证方式,

        this.exchange = exchange;
    }

    public String getHost() {
        return host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public int getMode() {
        return mode;
    }

    public void setMode(int mode) {

        if(mode == 1){ //工作队列模式不需要设计交换机,但是队列名称一定要有
            if(exchange != null){
                throw new RuntimeException("工作队列模式无需设计交换机");
            }
            if(queue == null || queue.trim().equals("")){
                throw new RuntimeException("工作队列模式名称不能为空");
            }
            if(isDurable == false){
                throw new RuntimeException("工作队列模式必须开启持久化");
            }
        }else if(mode == 2){ //路由模式必须设计交换机,但是不能设计队列
            if(exchange == null){
                throw new RuntimeException("路由模式下必须设置交换机");
            }
            if(queue != null){
                throw new RuntimeException("路由模式无须设计队列名称");
            }
        }

        this.mode = mode;
    }

    public String getQueue() {
        return queue;
    }

    public void setQueue(String queue) {
        this.queue = queue;
    }

    public boolean isDurable() {
        return isDurable;
    }

    public void setDurable(boolean durable) {
        isDurable = durable;
    }

    public int getConnectionTimeout() {
        return connectionTimeout;
    }

    public void setConnectionTimeout(int connectionTimeout) {
        this.connectionTimeout = connectionTimeout;
    }

    public void sendMessage(String msg){

        System.out.println("发送消息......");
    }

    /**
     * set方法的好处是参数的设计更加的灵活,但是通过set方式设置对象属性时,对象有可能存在中间状态(无效状态),
     * 并且进行属性校验时有前后顺序约束.
     * 怎么保证灵活设置参数又不会存在中间状态呢? 答案就是: 使用建造者模式
     */
    public static void main(String[] args) {
        RabbitMQClient2 client2 = new RabbitMQClient2();
        client2.setHost("192.168.52.123");
        client2.setQueue("queue");
        // 如果将setMode方法放在setQueue之前，会报错：工作队列模式名称不能为空，说明属性校验时有前后顺序约束
        client2.setMode(1);
        client2.setDurable(true);
        client2.sendMessage("Test-MSG2");
    }
}

```

**3) 建造者方式实现**

建造者使用步骤如下:

1. 目标类的构造方法要传入Builder对象
2. Builder建造者类位于目标类内部,并且使用static修饰
3. Builder建造者对象提供内置的各种set方法,注意set方法返回的是builder对象本身
4. Builder建造者类提供build()方法实现目标对象的创建

```java
public class 目标类{
	
    //目标类的构造方法需要传入Builder对象
    public 目标类(Builder builder){
        
    }

    public 返回值 业务方法(参数列表){
        
    }
    
    //Builder建造者类位于目标类内部,并且使用static修饰
    public static class Builder(){
        //Builder建造者对象提供内置的各种set方法,注意set方法返回的是builder对象本身
        private String xxx;
        public Builder setXxx(String xxx){
            this.xxx = xxx;
            return this;
        }
        
        //Builder建造者类提供build()方法实现目标对象的创建
        public 目标类 build(){
            //校验
            return new 目标类(this);
        }
    }
}
```

**重写案例代码**

```java
/**
 * 建造者模式
 * 1.目标类的构造方法要传入一个Builder对象
 * 2.builder类位于目标类的内部，并且使用static修饰
 * 3.builder类对象提供内置各种set方法，注意：set方法的返回值是builder本身
 * 4.builder类提供一个build()方法，实现目标对象的创建
 */
public class RabbitMQClient3 {

    //私有构造方法
    private RabbitMQClient3(Builder builder) {

    }

    public static class Builder {
        // 属性密闭性,保证对象不可变
        private String host = "127.0.0.1";
        private int port = 5672;
        private int mode;
        private String exchange;
        private String queue;
        private boolean isDurable = true;
        int connectionTimeout = 1000;

        public Builder setHost(String host) {
            this.host = host;
            return this;
        }

        public Builder setPort(int port) {
            this.port = port;
            return this;
        }

        public Builder setMode(int mode) {
            this.mode = mode;
            return this;
        }

        public Builder setExchange(String exchange) {
            this.exchange = exchange;
            return this;
        }

        public Builder setQueue(String queue) {
            this.queue = queue;
            return this;
        }

        public Builder setDurable(boolean durable) {
            isDurable = durable;
            return this;
        }

        public Builder setConnectionTimeout(int connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
            return this;
        }


        //返回构建好的复杂对象
        public RabbitMQClient3 build() {
            //首先进行校验
            if (mode == 1) { //工作队列模式不需要设计交换机,但是队列名称一定要有
                if (exchange != null) {
                    throw new RuntimeException("工作队列模式无需设计交换机");
                }
                if (queue == null || queue.trim().equals("")) {
                    throw new RuntimeException("工作队列模式名称不能为空");
                }
                if (isDurable == false) {
                    throw new RuntimeException("工作队列模式必须开启持久化");
                }
            } else if (mode == 2) { //路由模式必须设计交换机,但是不能设计队列
                if (exchange == null) {
                    throw new RuntimeException("路由模式下必须设置交换机");
                }
                if (queue != null) {
                    throw new RuntimeException("路由模式无须设计队列名称");
                }
            }
            return new RabbitMQClient3(this);
        }
    }

    public void sendMessage(String msg) {
        System.out.println("发送消息......");
    }

}
```

测试

```java
/**
 * 测试
 */
public class APP {
    public static void main(String[] args) {
        //使用链式编程设置参数
        RabbitMQClient3 client = new RabbitMQClient3.Builder()
                .setHost("192.168.52.123")
                .setMode(2)
                .setExchange("text-exchange")
                .setPort(5672)
                .setDurable(true)
                .build();

        client.sendMessage("Test");
    }
}
```

### 4.5 建造者模式总结

**1) 建造者模式与工厂模式区别** 

- 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。
- 建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。

> 举例: 顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。

**2) 建造者模式的优缺点**

- 优点
  - 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
  - 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
  - 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
  - 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。

- 缺点

  - 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。


**3) 应用场景**

- 建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。
  - 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
  - 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。

## 5.原型模式

### 5.1 原型模式介绍

定义: 原型模式(Prototype Design Pattern)用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。

> 西游记中的孙悟空 拔毛变小猴,孙悟空这种根据自己的形状复制出多个身外化身的技巧,在面向对象软件设计领域被称为原型模式.孙悟空就是原型对象.

![image-20230822180103630](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230822180103630.png)

**原型模式主要解决的问题**

如果创建对象的成本比较大,比如对象中的数据是经过复杂计算才能得到,或者需要从RPC接口或者数据库等比较慢的IO中获取,这种情况我们就可以使用原型模式,从其他已有的对象中进行拷贝,而不是每次都创建新对象,进行一些耗时的操作.

### 5.2 原型模式原理

原型模式包含如下角色：

* 抽象原型类(Prototype)：它是声明克隆方法的接口,是所有具体原型类的公共父类,它可以是抽象类也可以是接口
* 具体原型类(ConcretePrototype)：实现在抽象原型类中声明的克隆方法,在克隆方法中返回自己的一个克隆对象
* 客户类(Client)：在客户类中,让一个原型对象克隆自身从而创建一个新的对象.由于客户类针对抽象原型类Prototype编程.因此用户可以根据需要选择具体原型类,系统具有较好的扩展性,增加或者替换具体原型类都比较方便

![image-20230822180217879](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230822180217879.png)

### 5.3 深克隆与浅克隆

根据在**复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量** 这个条件,原型模式的克隆机制分为两种,即浅克隆(Shallow Clone)和深克隆(Deep Clone)

**1) 什么是浅克隆**

被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象(克隆对象与原型对象共享引用数据类型变量)。

![image-20230822180244173](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230822180244173.png)

**2) 什么是深克隆**

除去那些引用其他对象的变量，被复制对象的所有变量都含有与原来的对象相同的值。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。

![image-20230822180302815](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230822180302815.png)

Java中的Object类中提供了 `clone()` 方法来实现**浅克隆**。需要注意的是要想实现克隆的Java类必须实现一个标识接口 `Cloneable` ,来表示这个Java类支持被复制.

Cloneable 接口是上面的类图中的抽象原型类，而实现了 Cloneable 接口的子实现类就是具体的原型类。代码如下：

**3) 浅克隆代码实现：**  

```java
/**
 * 具体原型类
 * 实现Cloneable标识接口，标识当前类对象可复制
 */
public class ConCreatProToType implements Cloneable {

    public ConCreatProToType() {
        System.out.println("具体的原型对象创建成功！");
    }

    @Override
    protected ConCreatProToType clone() throws CloneNotSupportedException {
        System.out.println("克隆对象复制成功！");
        return (ConCreatProToType) super.clone();
    }
}
```

测试

```java
public void test1() throws CloneNotSupportedException {
    ConCreatProToType c1 = new ConCreatProToType();
    ConCreatProToType c2 = c1.clone();

    System.out.println("对象C1和C2是同一个对象吗？" + (c1 == c2));
}
```

**4) 深克隆代码实现**  

在 ConcretePrototype 类中添加一个对象属性为 Person 类型

```java
public class Person implements Serializable {

    private String name;

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
/**
 * 具体原型类
 * 实现Cloneable标识接口，标识当前类对象可复制
 */
public class ConCreatProToType implements Cloneable, Serializable {

    private Person person;

    public Person getPerson() {
        return person;
    }

    public void setPerson(Person person) {
        this.person = person;
    }

    public void show() {
        System.out.println("嫌疑人姓名：" + person.getName());
    }

    public ConCreatProToType() {
        System.out.println("具体的原型对象创建成功！");
    }

    @Override
    protected ConCreatProToType clone() throws CloneNotSupportedException {
        System.out.println("克隆对象复制成功！");
        return (ConCreatProToType) super.clone();
    }
}
```

测试

```java
public void test2() throws Exception {
    ConCreatProToType c1 = new ConCreatProToType();
    Person p1 = new Person("John");
    c1.setPerson(p1);

    // 复制操作
    ConCreatProToType c2 = c1.clone();
    Person p2 = c2.getPerson();
    p2.setName("Happy");

    c1.show();
    c2.show();
    System.out.println("对象P1和P2是同一个对象吗？" + (p1 == p2));
}
```

打印结果

![image-20230823155928811](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230823155928811.png)

> 说明: p1与p2是同一对象,这是浅克隆的效果,也就是对具体原型类中的引用数据类型的属性进行引用的复制

如果有需求场景中不允许共享同一对象，那么就需要使用**深拷贝**，如果想要进行深拷贝需要使用到对象序列化流 (对象序列化之后,再进行反序列化获取到的是不同对象).  代码如下:

```java
@Test
public void test3() throws Exception {
    ConCreatProToType c1 = new ConCreatProToType();
    Person p1 = new Person("John");
    c1.setPerson(p1);

    // 创建对象序列化输出流
    ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("a.txt"));
    // 将C1对象写到文件
    outputStream.writeObject(c1);
    outputStream.close();

    // 创建对象序列化输入流
    ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("a.txt"));
    // 读取对象
    ConCreatProToType c2 = (ConCreatProToType) inputStream.readObject();
    Person p2 = c2.getPerson();
    p2.setName("Happy");

    c1.show();
    c2.show();
    System.out.println("对象P1和P2是同一个对象吗？" + (p1 == p2));
}
```

打印结果：

![image-20230823160227559](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230823160227559.png)

> 注意：ConcretePrototype类和Person类必须实现Serializable接口，否则会抛NotSerializableException异常

其实现在不推荐大家用Cloneable接口，实现比较麻烦，现在借助Apache Commons或者 springframework 可以直接实现：

- 浅克隆：`BeanUtils.cloneBean(Object obj);BeanUtils.copyProperties(S,T);`
- 深克隆：`SerializationUtils.clone(T object);` 

BeanUtils是利用反射原理获得所有类可见的属性和方法，然后复制到target类。

SerializationUtils.clone() 就是使用我们的前面讲的序列化实现深克隆，当然你要把要克隆的类实现Serialization接口。

### 5.4 原型模式应用实例

模拟某银行电子账单系统的广告信发送功能,广告信的发送都是有一个模板的,从数据库查出客户的信息,然后放到模板中生成一份完整的邮件,然后交给发送机进行发送处理.

![image-20230823160535180](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230823160535180.png)

**发送广告信邮件UML类图** 

![image-20230823160555063](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230823160555063.png)

**代码实现**

广告模板代码 

```java
/**
 * 广告模板
 */
public class AdvTemplate {
    // 广告信名称
    private String advSubject = "xx银行本月还款达标，可抽iPhone14等好礼";

    // 广告新内容
    private String advContext = "达标用户请在2023年12月31日前参与抽奖......";

    public String getAdvSubject() {
        return advSubject;
    }

    public void setAdvSubject(String advSubject) {
        this.advSubject = advSubject;
    }

    public String getAdvContext() {
        return advContext;
    }

    public void setAdvContext(String advContext) {
        this.advContext = advContext;
    }
}
```

邮件类代码

```java
/**
 * 邮件类
 */
public class Mail {
    /**
     * 收件人
     */
    private String receiver;

    /**
     * 邮件名称
     */
    private String subject;

    /**
     * 称呼
     */
    private String appellation;

    /**
     * 邮件内容
     */
    private String context;

    /**
     * 邮件尾部 “xx版权所有”
     */
    private String tail;

    public Mail(AdvTemplate advTemplate){
        this.subject = advTemplate.getAdvSubject();
        this.context = advTemplate.getAdvContext();
    }

    public String getReceiver() {
        return receiver;
    }

    public void setReceiver(String receiver) {
        this.receiver = receiver;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getAppellation() {
        return appellation;
    }

    public void setAppellation(String appellation) {
        this.appellation = appellation;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

    public String getTail() {
        return tail;
    }

    public void setTail(String tail) {
        this.tail = tail;
    }
}
```

客户类

```java
/**
 * 业务场景
 */
public class Client {

    /**
     * 发送邮件数量
     */
    private static int MAX_COUNT = 6;

    /**
     * 发送邮件方法
     */
    public static void sendMail(Mail mail) {
        System.out.println("标题：" + mail.getSubject() + "\t 收件人" + mail.getReceiver() + "\t ...发送成功");
    }

    public static void main(String[] args) {
        int i = 0;
        // 定义模板
        Mail mail = new Mail(new AdvTemplate());
        mail.setTail("xxx银行版权所有");
        while (i < MAX_COUNT){
            // 每封邮件不同的信息
            mail.setAppellation(" 先生 （女士）");
            int num = new Random().nextInt(999999999);
            mail.setReceiver(num + "@" + "example.com");
            // 发送邮件
            sendMail(mail);
            i++;
        }
    }
}
```

运行结果

![image-20230823162952066](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230823162952066.png)

上面的代码存在的问题: 

- 发送邮件需要重复创建Mail类对象,而且Mail类的不同对象之间差别非常小,这样重复的创建操作十分的浪费资源.
- 这种情况我们就可以使用原型模式,从其他已有的对象中进行拷贝,而不是每次都创建新对象,进行一些耗时的操作.

------

**代码重构**

Mail类

```java
public class Mail implements Cloneable{

    /**
     * 收件人
     */
    private String receiver;

    /**
     * 邮件名称
     */
    private String subject;

    /**
     * 称呼
     */
    private String appellation;

    /**
     * 邮件内容
     */
    private String context;

    /**
     * 邮件尾部 “xx版权所有”
     */
    private String tail;

    public Mail(AdvTemplate advTemplate){
        this.subject = advTemplate.getAdvSubject();
        this.context = advTemplate.getAdvContext();
    }

    public String getReceiver() {
        return receiver;
    }

    public void setReceiver(String receiver) {
        this.receiver = receiver;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getAppellation() {
        return appellation;
    }

    public void setAppellation(String appellation) {
        this.appellation = appellation;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

    public String getTail() {
        return tail;
    }

    public void setTail(String tail) {
        this.tail = tail;
    }

    @Override
    protected Mail clone() {
        Mail mail = null;
        try {
            return (Mail) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

Client类

```java
public class Client {

    /**
     * 发送邮件数量
     */
    private static int MAX_COUNT = 6;

    /**
     * 发送邮件方法
     */
    public static void sendMail(Mail mail) {
        System.out.println("标题：" + mail.getSubject() + "\t 收件人" + mail.getReceiver() + "\t ...发送成功");
    }

    public static void main(String[] args) {
        int i = 0;
        // 定义模板
        Mail mail = new Mail(new AdvTemplate());
        mail.setTail("xxx银行版权所有");
        while (i < MAX_COUNT){
            // 每封邮件不同的信息
            // 使用clone方法
            Mail cloneMail = mail.clone();
            cloneMail.setAppellation(" 先生 （女士）");
            int num = new Random().nextInt(999999999);
            cloneMail.setReceiver(num + "@" + "example.com");
            // 发送邮件
            sendMail(cloneMail);
            i++;
        }
    }
}
```

### 5.5 原型模式总结

**原型模式的优点**

1. 当创建新的对象实例较为复杂时,使用原型模式可以简化对象的创建过程, 通过复制一个已有实例可以提高新实例的创建效率.

   > 比如，在 AI 系统中，我们经常需要频繁使用大量不同分类的数据模型文件，在对这一类文件建立对象模型时，不仅会长时间占用 IO 读写资源，还会消耗大量 CPU 运算资源，如果频繁创建模型对象，就会很容易造成服务器 CPU 被打满而导致系统宕机。通过原型模式我们可以很容易地解决这个问题，当我们完成对象的第一次初始化后，新创建的对象便使用对象拷贝（在内存中进行二进制流的拷贝），虽然拷贝也会消耗一定资源，但是相比初始化的外部读写和运算来说，内存拷贝消耗会小很多，而且速度快很多

2. 原型模式提供了简化的创建结构,工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构(具体工厂对应具体产品),而原型模式就不需要这样,原型模式的产品复制是通过封装在原型类中的克隆方法实现的,无须专门的工厂类来创建产品.

3. 可以使用深克隆的方式保存对象状态,使用原型模式将对象复制一份并将其状态保存起来,以便在需要的时候使用,比如恢复到某一历史状态,可以辅助实现撤销操作.

   > 在某些需要保存历史状态的场景中，比如，聊天消息、上线发布流程、需要撤销操作的程序等，原型模式能快速地复制现有对象的状态并留存副本，方便快速地回滚到上一次保存或最初的状态，避免因网络延迟、误操作等原因而造成数据的不可恢复。			

**原型模式缺点**

- 需要为每一个类配备一个克隆方法,而且该克隆方法位于一个类的内部,当对已有的类进行改造时需要修改源代码,违背了开闭原则.

**使用场景**

原型模式常见的使用场景有以下六种。

- 资源优化场景。也就是当进行对象初始化需要使用很多外部资源时，比如，IO 资源、数据文件、CPU、网络和内存等。

- 复杂的依赖场景。 比如，F 对象的创建依赖 A，A 又依赖 B，B 又依赖 C……于是创建过程是一连串对象的 get 和 set。

- 性能和安全要求的场景。 比如，同一个用户在一个会话周期里，可能会反复登录平台或使用某些受限的功能，每一次访问请求都会访问授权服务器进行授权，但如果每次都通过 new 产生一个对象会非常烦琐，这时则可以使用原型模式。

- 同一个对象可能被多个修改者使用的场景。 比如，一个商品对象需要提供给物流、会员、订单等多个服务访问，而且各个调用者可能都需要修改其值时，就可以考虑使用原型模式。

- 需要保存原始对象状态的场景。 比如，记录历史操作的场景中，就可以通过原型模式快速保存记录。

# 五、结构型模式（7种）

我们已经学习过了设计模式中的创建型模式. 创建型模式主要解决**对象的创建问题**,封装复杂的创建过程,解耦对象的创建代码和使用代码.

- 单例模式用来创建全局唯一对象
- 工厂模式用来创建不同但是相关类型的对象(继承同一父类或者接口的一组子类),由给定的参数来决定创建哪种类型的对象.
- 建造者模式是用来创建复杂对象,可以通过设置不同的可选参数,定制化地创建不同的对象.
- 原型模式针对创建成本比较大的对象,利用对已有对象进行复制的方式进行创建,以达到节省创建时间的目的.

> 结构型模式主要总结了一些类和对象组合在一起的经典结构，这些经典结构可以解决对应特定场景的问题。
>
> 一共包括七种：代理模式、桥接模式、装饰者模式、适配器模式、门面(外观)模式、组合模式、和享元模式。

## 1.代理模式

### 1.1 代理模式介绍

在软件开发中,由于一些原因,客户端不想或不能直接访问一个对象,此时可以通过一个称为"代理"的第三者来实现间接访问.该方案对应的设计模式被称为代理模式.

代理模式(Proxy Design Pattern ) 原始定义是：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许将请求提交给对象前后进行一些处理。

- 现实生活中的代理: **海外代购**

![image-20230823172319751](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230823172319751.png)

- 软件开发中的代理


代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到了中介的作用，它去掉客户不能看到的内容和服务或者增加客户需要的额外的新服务.

### 1.2 代理模式原理

代理（Proxy）模式分为三种角色：

* 抽象主题（Subject）类： 声明了真实主题和代理主题的共同接口,这样就可以保证任何使用真实主题的地方都可以使用代理主题,客户端一般针对抽象主题类进行编程。
* 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以在任何时候访问、控制或扩展真实主题的功能。
* 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。

![image-20230823172402611](https://typora-img-oss.oss-cn-nanjing.aliyuncs.com/image-20230823172402611.png)

### 1.3 静态代理实现

这种代理方式需要代理对象和目标对象实现一样的接口。

- 优点：可以在不修改目标对象的前提下扩展目标对象的功能。

- 缺点：

  1. 冗余：由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。

  2. 不易维护：一旦接口增加方法，目标对象与代理对象都要进行修改。

> 举例：保存用户功能的静态代理实现

```java
```





### 1.4 JDK动态代理



### 1.5 cglib动态代理



### 1.6 代理模式总结

















































